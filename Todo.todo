## Daily Task Breakdown

| Day | Date         | Phase                        | Task                                                                                           |
| --- | ------------ | ---------------------------- | ---------------------------------------------------------------------------------------------- |
| 1   | Mayâ€¯3,â€¯2025  | DB Design âœ”                  | Draft entities & relationships; create ERD; review with team                                   |
| 2   | Mayâ€¯4,â€¯2025  | DB Design âœ”                  | Normalize schema; define PK/FK; prepare migration plan                                         |
| 3   | Mayâ€¯5,â€¯2025  | Models & Migrations âœ”        | Scaffold Laravel project; create migration files for each table; run initial migrations        |
| 4   | Mayâ€¯6,â€¯2025  | Models & Migrations          | Implement Eloquent models; add relationships and fillable rules; refine migrations             |
| 5   | Mayâ€¯7,â€¯2025  | Controllers & Routing        | Generate resource controllers; outline methods (index, show, create, update, destroy)          |
| 6   | Mayâ€¯8,â€¯2025  | Controllers & Routing        | Move business logic into services; apply â€œskinny controllersâ€ pattern; secure with middleware  |
| 7   | Mayâ€¯9,â€¯2025  | Controllers & Routing        | Group and name routes; apply roleâ€‘based middleware; test endpoints with Postman                |
| 8   | Mayâ€¯10,â€¯2025 | Views                        | Set up main Blade layout & components; organize view folders per feature                       |
| 9   | Mayâ€¯11,â€¯2025 | Views                        | Build CRUD views for devices (list, detail, form); wire to controllers                         |
| 10  | Mayâ€¯12,â€¯2025 | UI/UX Improvements           | Apply responsive design, navigation UX; integrate alerts and status indicators                 |
| 11  | Mayâ€¯13,â€¯2025 | UI/UX & Auth                 | Implement authentication/roles (superâ€‘admin, admin, visitor) with Breeze; restrict views       |
| 12  | Mayâ€¯14,â€¯2025 | Testing                      | Scaffold PHPUnit/Pest; write unit tests for models and services                                |
| 13  | Mayâ€¯15,â€¯2025 | Testing                      | Write feature tests for controllers & routes; assert database changes                          |
| 14  | Mayâ€¯16,â€¯2025 | Testing                      | Add integration tests for user flows (login, device assignment, report generation)             |
| 15  | Mayâ€¯17,â€¯2025 | Iteration & Bugâ€‘fixing       | Triage issues from testing; optimize queries; finalize reporting feature                       |
| 16  | Mayâ€¯18,â€¯2025 | Deployment Prep & Scheduling | Configure scheduler for reports; prepare deployment scripts; set up cron via Laravel scheduler |
| 17  | Mayâ€¯19,â€¯2025 | Buffer & Launch              | Final QA, stakeholder walkthrough, launch to production                                        |

---
    
### Daysâ€¯1â€“2: Database Design

**Dayâ€¯1 (Mayâ€¯3)**

* Identify all entities (devices, users, roles, assignments, locations, archives).
* Draw an ERD in a tool like draw\.io; include cardinalities (1â€‘toâ€‘many for usersâ†’devices).
* Review requirements for archived/returned devices.


# Database Schema for Laravel Inventory System

We model three roles (visitor, admin, super-admin) using a **roles** table and a pivot table for many-to-many user-role assignments.  A **users** table holds each userâ€™s info (id, name, email, password, timestamps).  We include Laravelâ€™s built-in audit columns (`created_at`, `updated_at`) and a `deleted_at` column for soft-deletes.  User authentication uses a `roles` table (`id`, `name`) and a pivot `role_user` with foreign keys to `users.id` and `roles.id`.  In Laravel, this pivot implements Role-Based Access Control (RBAC) so each user can have one or more roles (e.g. an auditor user can also be an admin).

**Tables and Columns:** We define tables (with primary key `id` by convention) as follows:

* **users**: `id (PK)`, `name (string)`, `email (string, unique)`, `password (string)`, timestamps (`created_at`, `updated_at`), and `deleted_at` (for soft-deletes).

* **roles**: `id (PK)`, `name (string, unique)`, timestamps.

* **role\_user** (pivot): `user_id (FK â†’ users.id)`, `role_id (FK â†’ roles.id)`. No extra fields needed; the combination is the composite PK.

* **devices**: `id (PK)`, `name (string)`, `identifier (string, unique)` (e.g. company barcode), `state_id (FK â†’ device_states.id)`, timestamps, and `deleted_at`.  We enforce `identifier` as UNIQUE so each deviceâ€™s barcode is distinct. The `state_id` links to a **device\_states** table of possible statuses.

* **device\_states**: `id (PK)`, `name (string, unique)` (one of *active, returned, broken, not\_assigned, archived*), timestamps. This table enumerates all valid device states.

* **locations**: `id (PK)`, `name (string, unique)`, timestamps. Each row is an office or location name.

* **assignments**: `id (PK)`, `device_id (FK â†’ devices.id)`, `user_id (nullable FK â†’ users.id)`, `location_id (nullable FK â†’ locations.id)`, `assigned_by (FK â†’ users.id)`, `assigned_at (datetime)`, `returned_at (datetime, nullable)`.  Exactly one of `user_id` or `location_id` must be non-null (enforced by application logic or a database check) since a device is either with a user *or* at a location. The `assigned_by` field records which admin user performed the assignment.

* **device\_state\_histories**: `id (PK)`, `device_id (FK â†’ devices.id)`, `from_state_id (FK â†’ device_states.id)`, `to_state_id (FK â†’ device_states.id)`, `changed_by (FK â†’ users.id)`, `changed_at (timestamp)`, `note (string, nullable)`.  Each entry logs a state change for a device, recording the old and new state, who changed it, and when. (Alternatively, you could record just the new state and infer the old one.)

* **device\_archives**: `id (PK)`, `device_id (FK â†’ devices.id)`, `archived_by (FK â†’ users.id)`, `archived_at (timestamp)`, `reason (string)`.  This table logs when and why a device was archived. When a device is archived, we set its `deleted_at` flag and insert a record here so the action is auditable.

Each tableâ€™s primary key is `id`.  Foreign keys (FK) enforce relationships: e.g. `devices.state_id â†’ device_states.id`, `assignments.device_id â†’ devices.id`, `assignments.user_id â†’ users.id`, etc.  All tables use Eloquentâ€™s timestamp columns (`created_at`, `updated_at`) for auditing.

## Relationships and Cardinality

* **Userâ€“Role**: Many-to-many. A user can have multiple roles (via `role_user` pivot), and a role can apply to many users. This enables role-based permissions.
* **Userâ€“Assignments**: One user can create many assignment records, and one user can have many devices over time. In the `assignments` table, each record links to one user. Over time, a user may appear in many assignment rows (one-to-many).
* **Locationâ€“Assignments**: One location can be the destination for many assignment events. A single assignment row references one location, so locations have one-to-many to assignments.
* **Deviceâ€“Assignments**: One device can have many assignment events (each time it is checked out or returned). Each assignment links to one device, so deviceâ†’assignments is one-to-many. At any moment, a device is assigned to at most one entity.
* **Deviceâ€“DeviceStates**: Each device has one current state (`devices.state_id â†’ device_states.id`), and each state (e.g. â€œactiveâ€) can apply to many devices (one-to-many). We use the states table to constrain valid statuses.
* **Deviceâ€“DeviceStateHistories**: One device can have many historical state records; each history record links to one device (one-to-many). Similarly, one state can appear as the â€œfromâ€ or â€œtoâ€ state in many history rows. Each change event is logged.
* **Deviceâ€“DeviceArchives**: One device can be archived once (or multiple times, if allowed) â€“ each archive log belongs to one device (one-to-many). Each log references who archived it.  Likewise, one user (admin) can archive many devices over time (one-to-many from users to device\_archives).

Below is an ERD in Mermaid syntax showing these entities and relationships. Each arrow uses crowâ€™s-foot notation (e.g. `||--o{` for one-to-many) and labels the relationship.

```mermaid
erDiagram
    USERS }o--o{ ROLES : "has"
    USERS ||--o{ ASSIGNMENTS : "creates"
    LOCATIONS ||--o{ ASSIGNMENTS : "contains"
    DEVICES ||--o{ ASSIGNMENTS : "assigned_to"
    DEVICES ||--o{ DEVICE_STATE_HISTORIES : "changed"
    DEVICE_STATES ||--o{ DEVICE_STATE_HISTORIES : "defines"
    DEVICE_STATES ||--o{ DEVICES : "status"
    DEVICES ||--o{ DEVICE_ARCHIVES : "archived"
    USERS ||--o{ DEVICE_ARCHIVES : "performed_by"
```

## Handling Returned and Archived Devices

When a device is **returned** (e.g. a user brings it back for maintenance), we update its assignment and state. In practice, we set that assignmentâ€™s `returned_at` timestamp and create a state-history record switching the deviceâ€™s status to â€œreturnedâ€ (or similar).  The deviceâ€™s current `state_id` is updated to â€œreturnedâ€. This ensures we have a log of when and why the device was returned (the `device_state_histories` entry can include a note).

For **archiving** (soft-deleting) a device, we mark it as archived and record metadata. In Laravel this is done by setting the deviceâ€™s `deleted_at` timestamp rather than deleting the row. We also set its current state to â€œarchivedâ€ and insert a record into `device_archives` with `archived_by` and `reason`. This acts like a â€œrecycle binâ€: the device remains in the database (and can be restored if needed), but is flagged as inactive.  Soft deletes let us retain full history â€“ Laravelâ€™s Eloquent will ignore â€œdeletedâ€ devices by default but we can restore or audit them as needed.


**Dayâ€¯2 (Mayâ€¯4)**

* Normalize tables to 3NF; eliminate redundancy ([CMARIX][1]).

| Concept                         | Wrong Example ğŸ§Ÿâ€â™‚ï¸                                    | Right Example ğŸ’                 |
| ------------------------------- | --------------------------------------------------- | -------------------------------- |
| **Atomic values (1NF)**         | One field has multiple emails (`a,b,c`)             | Split into `user_emails` table   |
| **Repeating groups (1NF)**      | One table with product1, product2, product3 columns | Break into rows in a child table |
| **Partial dependency (2NF)**    | `role_name` in a composite key table                | Move to separate `roles` table   |
| **Composite Key**               | A key made of multiple columns                      | `role_user (user_id, role_id)`   |
| **Transitive dependency (3NF)** | `state_name` depending on `state_id`                | Move to `device_states` table    |


* Define primary/foreign keys, pivot tables for manyâ€‘toâ€‘many (e.g., devicesâ†”locations).
* Draft migration plan: one migration per table, descriptive names ([ClickySoft][3]).

### Daysâ€¯3â€“4: Models & Migrations

**Dayâ€¯3 (Mayâ€¯5)**

* `composer create-project laravel/laravel inventory-system` to scaffold.
* Create migrations: `php artisan make:migration create_devices_table` etc.; run `php artisan migrate` ([Cloudways][4]).

**Dayâ€¯4 (Mayâ€¯6)**

* Build Eloquent models; define `$fillable`, casts, relationships (hasMany, belongsTo) ([Medium][5]).
* Refine migrations: add indexes, constraints, softâ€‘deletes.
* Seed initial roles via a RoleSeeder.

### Daysâ€¯5â€“7: Controllers & Routing

**Dayâ€¯5 (Mayâ€¯7)**

* Generate resource controllers: `php artisan make:controller DeviceController --resource` for each model.
* Stub out index/show/create/update/destroy methods.

**Dayâ€¯6 (Mayâ€¯8)**

* Extract business logic into Service classes for assignments and reports (skinny controllers) ([DEV Community][6]).
* Validate via FormRequests, authorize via Policies.

**Dayâ€¯7 (Mayâ€¯9)**

* Organize routes in `routes/web.php` using groups, prefixes, names ([Medium][7]).
* Attach roleâ€‘middleware (`superadmin`, `admin`, `visitor`) to route groups.
* Manual test endpoints with Postman.

### Daysâ€¯8â€“9: Views

**Dayâ€¯8 (Mayâ€¯10)**

* Create master layout in `resources/views/layouts/app.blade.php`; define nav, footer ([Laravel][8]).
* Build reusable Blade components (alerts, tables).

**Dayâ€¯9 (Mayâ€¯11)**

* Develop device CRUD views (index, form, detail) under `views/devices/`.
* Use Blade directives, loops, and includes for DRY structure ([Medium][9]).

### Daysâ€¯10â€“11: UI/UX & Auth

**Dayâ€¯10 (Mayâ€¯12)**

* Apply responsive grid (Tailwind or Bootstrap), ensure usability on mobile.
* Add flash notifications, loading indicators, error highlights ([Medium][10]).

**Dayâ€¯11 (Mayâ€¯13)**

* Install Laravel Breeze for auth scaffolding; set up roles in registration flow ([Laravel Daily][11]).
* Restrict pages: superâ€‘admin full, admin limited, visitor readâ€‘only.

### Daysâ€¯12â€“14: Testing

**Dayâ€¯12 (Mayâ€¯14)**

* Configure PHPUnit/Pest; create tests directory structure (Unit, Feature).
* Write unit tests for models and services.  ([WPWeb Infotech][12]).

**Dayâ€¯13 (Mayâ€¯15)**

* Write feature tests for controller actions: device creation, assignment, report generation ([Laracasts][13]).

**Dayâ€¯14 (Mayâ€¯16)**

* Write integration tests covering user loginâ€¯â†’â€¯viewâ€¯â†’â€¯print report flow ([Laravel][14]).

### Daysâ€¯15â€“17: Iteration, Deployment & Buffer

**Dayâ€¯15 (Mayâ€¯17)**

* Fix bugs surfaced by tests; optimize N+1 queries with eager loading.
* Finalize report export (PDF/CSV).

**Dayâ€¯16 (Mayâ€¯18)**

* Set up task scheduler in `app/Console/Kernel.php` for daily summaries ([Laravel][15]).
* Write deployment scripts (Envoyer, Forge, or GitHub Actions).

**Dayâ€¯17 (Mayâ€¯19)**

* Buffer: final QA, stakeholder demo, document the system, deploy to production.

